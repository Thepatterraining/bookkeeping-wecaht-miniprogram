---
ruleType: Model Request
description: 现状分析与需求验证
globs:
---

# 现状分析与需求验证

## 1. 概述

**任务目标**：分析现有代码实现，验证需求与现状的差距，生成改造清单。

**输入**：`.spec/{feature_name}/requirements.md`（已确认存在）

**输出**：`.spec/{feature_name}/current_state.md`

---

## 1.5 强制输出结构

> ⚠️ **输出必须以"核心发现摘要"开头**，在第1章之前。

### 核心发现摘要必须包含：

| 子章节 | 内容要求 |
|--------|----------|
| 关键结论 | 一句话总结现状评估 |
| 改造规模 | 表格：涉及文件数 / 代码改造点 / 外部协调数 / 预计工时 |
| 风险评级 | 总体风险等级（\uD83D\uDD34高 \uD83D\uDFE1中 \uD83D\uDFE2低）+ 主要风险类别 |
| 关键发现 | 每个包含：优先级(P0/P1/P2) + 位置(文件+行号) + 影响 + 改造建议 + 外部依赖 |
| 外部协调清单 | 表格：团队 / 协调内容 / 紧急程度 / 预计周期 |

### 优先级定义：

- **P0 (阻塞性)**: 基础数据模型、核心业务逻辑、阻塞上线
- **P1 (部分阻塞)**: 扩展点兼容、灰度配置、影响部分功能
- **P2 (非阻塞)**: 性能优化、文档完善、辅助功能

---

## 2. 红线要求

> ⚠️ 以下要求必须严格遵守，违反将导致分析无效。

| # | 红线项 | 执行动作 | 验证标准 |
|---|--------|----------|----------|
| 1 | 枚举/参数类验证 | `get_code_snippet({类名})` | **必须**获取完整定义，**禁止**"从代码推断"；列出完整字段表格 |
| 2 | 参数验证 | `get_code_snippet({参数类名})` | 字段名、类型、数量 100% 一致；识别字段扩展需求 |
| 3 | 外部依赖 | 检查 import 中非本项目的类 | 标注来源 jar 包、方法签名 |
| 4 | 分支覆盖 | 分析方法内所有 if/else/switch | 每个分支都已追踪调用链 |
| 5 | 分流条件 | 查找分支条件引用的常量 | 所有常量（如 `MccConstant.XXX`）已标注 |
| 6 | 改造点精确定位 | 每个改造项必须包含完整信息 | **必须**：文件路径+行号+优先级(P0/P1/P2)；**禁止**"需要改造XXX模块" |

---

## 3. 执行流程

> ⚠️ **核心原则**：分步分析，边分析边写入文档。每完成一个 Step 立即写入对应章节，避免信息遗漏，保证结果完整性，忽略性能和效率的影响，忽略 token 的消耗。

### Step 1: 提取需求点 → 写入附录

从 `requirements.md` 提取所有明确的业务需求，整理为编号列表。

**立即写入**：附录 - 需求列表（后续步骤会补充为需求-接口映射表）

### Step 2: 逐个需求发现接口 → 写入第1章、附录

对 **每个需求点** 循环执行：
1. 先使用 CodeGraph 搜索相关接口
2. 识别涉及的服务、组件、枚举、外部依赖
3. **立即写入**：第1章对应小节（服务架构）、附录映射表

### Step 3: 逐个接口深挖 → 写入第2章、第5章

对 **每个接口** 循环执行：

1. **基本信息**：接口类型 + 实现类.方法 + 功能描述

2. **调用链路深挖**（核心步骤）：
使用 CodeGraph 搜索相关图谱检索能力来做多跳和递归检索
  - 从入口方法开始，递归分析每一层调用
  - 对每个被调用的方法，继续向下追踪，直到：
    - 到达基础设施层（DB/RPC/缓存/MQ）
    - 或调用外部 jar 包方法
  - 记录完整调用链：`入口 → 应用层 → 领域层 → 基础设施层`
  - 在调用链中标注：哪些节点可能需要改造（参数传递、逻辑变更）

3. **分支发现**（红线 #4）：
  - 分析调用链上每个方法的 if/else/switch
  - 追踪每个分支的独立调用路径
  - 标注分流条件引用的常量（红线 #5）
  - 要有关键位置和分支判断逻辑
  - 涉及到的方法要有完整的权限定名和参数定义

4. **源代码验证**（红线 #1, #2）：
  - 调用链涉及的参数类：`get_code_snippet` 逐字段验证
  - 调用链涉及的枚举：`get_code_snippet` 验证编码值和包路径

5. **外部依赖识别**（红线 #3）：检查 import，标注 jar 包来源，可以通过规则 @spec-mcp-usage.md 中提到的工具进行解析

6. **立即写入**：第2章对应接口小节（含完整调用链）、第5章数据模型

### Step 4: 逐个需求打标 → 写入第3章

对 **每个需求点** 循环执行：
1. 基于已分析的接口，判断现状是否满足
2. ✅ 满足：写清"为什么满足"
3. ❌ 不满足：写清"缺什么/不一致在哪里"
4. **立即写入**：第3章对应需求小节

### Step 5: 逐个❌需求生成改造项 → 写入第4章

对 **每个 ❌ 需求** 循环执行：
1. 从对应接口分析中提取改造项（接口签名、业务逻辑、数据模型、下游依赖）
2. 每个改造项必须包含：**位置 + 行号 + 改造内容（代码） + 关联需求**
3. **立即写入**：第4章对应改造项

### Step 6: 风险评估与验证 → 写入第6-9章

1. 汇总分析过程中发现的问题和风险 → 写入第6章
2. 如需求涉及性能要求 → 写入第7章
3. 提出改造建议 → 写入第8章
4. 需求验证（合理性、完整性、准确性、一致性）→ 写入第9章
5. 汇总所有 TO-DO 项 → 写入附录

---

## 4. 输出文档规范

### 4.1 章节结构

按顺序执行，每完成一章立即写入文档：

| 章节 | 内容 | 必须 |
|------|------|------|
| 1 | 服务架构现状（服务、组件、枚举、外部依赖） | ✅ |
| 2 | 接口现状分析（调用链路、参数、执行路径） | ✅ |
| 3 | 改造需求分析（✅/❌ 打标） | ✅ |
| 4 | 具体改造清单（位置 + 行号 + 内容） | ✅ |
| 5 | 数据模型现状 | ✅ |
| 6 | 问题识别与风险评估 | ✅ |
| 7 | 性能现状（仅当需求含"性能/QPS/响应时间"时） | 条件 |
| 8 | 改造建议 | ✅ |
| 9 | 需求验证结果（问题、建议、模糊点、澄清问题） | ✅ |
| 附录 | 需求-接口映射表、TO-DO 列表 | ✅ |

### 4.2 格式规范

**代码块**：
```java
// ClassName.java 第40-48行
if (condition) {
    // 逻辑说明
}
```

**调用链路**（不使用代码块）：
```
ServiceImpl.method() [入口层]
→ ApplicationService.method() [应用层]
→ [分支1] ManagerA.method() [领域层]
→ [分支2] ManagerB.method() [领域层]
```

**状态标注**：✅ 已满足 | ❌ 需改造

**改造项格式**：
```
#### 4.1.1 改造项名称
- **关联需求**：需求X
- **位置**：`ClassName.java`
  - **第65-70行**：改造描述1
  - **第117-127行**：改造描述2
- **内容**：具体改造说明
```

**TO-DO 格式**：`- [ ] [待确认/待调研/风险] 描述 - 来源：章节X`

---

## 5. 完成检查清单

完成所有章节后，逐项确认：

### 需求维度
- [ ] 每个需求点都在"需求-接口映射表"中至少出现 1 次
- [ ] 每个需求点在第 3 章都有独立小节并标注 ✅/❌
- [ ] 无"孤儿需求"（只在 requirements.md 出现）

### 接口维度
- [ ] 映射表中每个接口在第 2 章都有对应小节
- [ ] 每个接口包含：基本信息 + 调用链路 + 入参结构 + 执行路径 + 下游依赖
- [ ] 关键结论有代码片段或搜索结果作为依据

### 改造维度
- [ ] 每个 ❌ 需求在第 4 章都有至少 1 个改造项
- [ ] 每个改造项可反向追溯到对应需求点
- [ ] 每个改造项包含：位置 + 行号 + 改什么 + 为什么改

### 红线维度
- [ ] 所有枚举已用 `get_code_snippet` 验证（红线 #1）
- [ ] 所有参数类已用 `get_code_snippet` 验证（红线 #2）
- [ ] 外部依赖已识别并标注来源 jar 包（红线 #3）
- [ ] 所有分支已分析（红线 #4）
- [ ] 分流条件常量已标注（红线 #5）
- [ ] 关键代码和改造点已标注行号（红线 #6）

### TO-DO 维度
- [ ] 待确认项已用不同关键词重新搜索
- [ ] 确认无法获取答案后才标记为"待确认"
- [ ] 每个 TO-DO 项标注了来源章节

---

## 6. 需求分析关键问题

分析时思考以下问题：

1. **概念区分**：系统自动判断 vs 用户主动选择？
2. **职责边界**：新需求是否跨越现有职责边界？
3. **完整流程**：哪些环节需要改造？
4. **设计意图**：现有设计是否与新需求冲突？
5. **数据来源**：判断逻辑所需数据从哪里来？这个环节是否是最佳处理位置？

---

## 7. 流转确认

**确认话术**：
> "现状分析和需求验证已完成，请查看 `.spec/{feature_name}/current_state.md`。如果没有问题，我们进入方案设计阶段。"

**流转输出**：
- 现状分析文档路径
- 关键发现摘要（3-5 条）
- 未解决的 TO-DO 项列表

---

## 8. 参考格式示例

以下是"核心发现摘要"的参考格式：

```markdown
## 核心发现摘要 (Executive Summary)

### 关键结论
**现状评估**: 本代码库缺少对"XXX"的支持，需要进行系统性改造。

**改造规模**:
- 涉及文件: 11个核心文件需改造
- 代码改造点: 14个主要改造项
- 外部协调: 4个外部团队需协调
- 预计工时: 55人天

**风险评级**: \uD83D\uDFE1 中高等风险 (主要风险: 兼容性、外部依赖)

### 最关键发现

#### 1. \uD83D\uDD34 核心枚举值缺失 (P0 - 阻塞性)
**发现**: `XXXEnum` 中不存在"YYY"枚举值
**位置**: `xxx/enums/XXXEnum.java` (第19-98行)
**影响**: 这是功能的基础，所有其他改造都依赖此枚举值
**改造**: 需新增 `YYY(12, "描述")` 枚举值
**外部依赖**: 需协调XX团队同步新增

### 外部协调清单

| 团队 | 协调内容 | 紧急程度 | 预计周期 |
|------|---------|---------|---------|
| XX团队 | 枚举值同步 | \uD83D\uDD34最高 | 1周 |
```
